<!DOCTYPE html>
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta charset="UTF-8">
<meta name="description" content="AllTheStrings README">
<meta name="keywords" content="AllTheStrings,C++,programming,strings,readme">
<meta name="author" content="chris" >

<title>README</title>

<link rel="stylesheet" type="text/css" href="light.css" title="preferred">
<link rel="alternate stylesheet" type="text/css" href="evening.css" title="alternate1">
<link rel="stylesheet" type="text/css" href="prettify.css">
</head>

<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

<body style="font-family:Trebuchet MS" style="color:#697c52" style="background-color:#E6E6FA">
<div id="content">
<center>
<img src="AllTheStrings.png" alt="allthestrings" style="font-family:Lucida Sans Unicode" color="#697c52" font-style="" italic="" font-size="30px">

<h1>
All The Strings<br> 
An easy-to-use  C++ Strings Library
</h1>
</center>
<p>
<div>
<table>
  <tbody><tr>
    <td>Programmer:</td>
    <td>Chris Reid</td> 
  </tr>
  <tr>
    <td>Year:</td>
    <td>2018</td> 
  </tr>

  <tr>
    <td>Version:</td>
    <td>1.2</td> 
  </tr>
  <tr>
    <td>contact:</td>
    <td>spikeysnack@gmail.com</td>
  </tr>
</tbody></table>
</div>

<br>

<h1>INTRO</h1>

<h2>
  Hello and welcome.
  <b>AllTheStrings</b> is a C++ strings utlity library <br>
  that makes programming with strings and string manipulation easy.<br>
</h2>

<p>
<pre>
One feature of AllTheStrings is that it makes an effort to be
non-destructive of the original string.
 
Every function returns a brand new object or collection of new objects.

This functional approach ensures that data is only changed permanently
when you want it to be; the original string is always available for use. 
Most of string formatting is in the output stage, usually the original string
is used again in its original form or discarded after that.
   
This may not be the fastest or most efficient way to work with strings, 
but it is the safest, and often the easiest.
  
The STL std::string class already has optimized assignment and copying built in,
so unless you are creating huge strings    
( and then you should write your own huge string library) 
there  should be no problem with speed or memory. 
  
All the AllTheStrings functions are enclosed in the namespace <font color="blue">AllTheStrings</font>.
It is included automatically when including the <font color="green">AllTheStrings.h</font> header.
You can just call the functions without any preamble. 
<p> 
<hr>
<h1>Usage</h1>
Using the library is an easy process:
<OL>

  <li> #include <font color="green">"AllTheStrings.H"</font>  Single Library version (no object file needed)</li>

  <li> #include <font color="green">"AllTheStrings.h"</font> </li>

  <li> link in <font color="blue">AllTheStrings.o</font> into your compile.</li> 

  <li> or add libAllTheStrings.so  as <code><font color="magenta"> -lAllTheStrings</font></code> into your compile. </li> 
</OL>

<pre class="prettyprint" >
#include &lt;iostream&gt;
#include &lt;string&gt;
#include "AllTheStrings.h" // imports functions and "AllTheStrings" namespace too

namespace test{
  using std::string;   
  using std::cout;
  using std::endl;
};

int main(int argc, char* argv[] , char* env[])
{

  using namespace test; // adds only the objects we are using

  string s{"Dogs are man's best friend."};
  cout << s << "\n";
  string t{s};
  string tmp{"best"};
  
  // all caps
  cout << "all_caps:\t" << all_caps(t) << "\n";

  // quote
  cout << "quote:\t" << quote(t) << "\n";

  // unquote
  cout << "unquote:\t" <<  unquote(quote(t)) << endl;

  string x = "  This \n string Has  \r probelms \n  .\n  ";

  cout << x << "\n";

  // chomp
  string y = chomp(x);
  cout << "chomp:\t" << y << endl;

  // sentence case
  y = sentence_case(y);
  cout << "sentence_case:\t" << y << endl;

  // replace word
  y =  replace_word(y, "probelms .", "problems.");
  cout << "replace_word:\t" << y << endl;

  // find word
  auto pos = y.find("has");
  
  //insert at position
  z = insert_word(y, "no" , pos+3) 
  cout << "insert_word:\t"  << z << endl;

 return 0;
}

<code><font size="3" color="blue"><pre>
     Dogs are man's best friend.


     all_caps:  DOGS ARE MAN'S BEST FRIEND.

     quote:	"Dogs are man's best friend."

     unquote:	Dogs are man's best friend.
     
                  This 
                probelms 
                .
 
     chomp:	This string Has probelms . 
     
     sentence_case:  This string has probelms .

     replace_word:   This string has problems.

     insert_word:    This string has no problems.
     
</pre></font></code>
</pre>

<hr>

<h1>LICENSE</h1>
<h2>	Free for all C++11 uses. No guarantees implied, or given.</h2>
<p>	
<hr>
<h1>INSTALLATION</h1>

<h2>
	Installation is by default into <i>/usr/local/lib</i><br> 
	and <i>/usr/local/include</i> <br> 
	and requires admin or sudo privileges.<br>
	Alternatively you may put <i>libAllTheStrins.so.1</i> and its<br>
	link <i>libAllTheStrings.so</i> and the associated header<br>
	<i>AllTheStrings.h </i><br>
	in a devel location of your choosing. <br>

	Use a standard "make all" and  "make install" command.<br>
</h2>	 


<font size="3" color="blue">
<code>
<pre>
	Steps:<br>

	-- make all <br>

	-- (optionally) make tests and run the tests in the test directory <br>
           before installing system-wide. <br>

	-- sudo make install <br>

	-- put <b>"#include AllTheStrings.h"</b>  in your C++ program.<br>

	-- add <i>AllTheStrings.o</i> to your compilation string.<br>

	   <font size="3">or</font><br>

	-- make libAllTheStrings.so (default)<br>
                This will create libAllTheStrings.so.1 and a soft link to
                it as libAllTheStrings.so.


	-- put <i>AllTheStrings.h</i> in a dir recognized by your compiler chain <br>
           or the current directory. <br>

	-- put <b>"#include AllTheStrings.h"</b>  in your C program.<br>

	-- add <i>-lAllTheStrings</i> to your compilation command.<br>

	--   or use rpath  (relative path)   <br>
	        Makefile: <br>
		    <b>LIBINCLUDES=$(PWD)  <br>
		    -L -Wl,-rpath=$(LIBINCLUDES)/</b><br>

	-- compile and run <br>

</pre>
</code>
</font>

<p>
<hr>

<h1>NORMAL USAGE</h1>
<h2>Simple, normal object-oriented C++ programming:</h2> 
<pre class="prettyprint">
#include &lt;iostream&gt;
#include &lt;string&gt;

string y{"                (y)            "};
cout << "trim:\t" << "[" << trim(y) << "]\n";

string z  = pad(y, 20, 'X' );
cout << "pad:\t"<<  "[" << z << "]\n";

cout << "[" <<  y  << "]\n";

cout << "rm_dblspaces:\t" << "[" << rm_dblspaces(y)  << "]\n";


z = " [ q w  t e  e  4 5 66 7 77     7 888 ]";
cout << "[" <<  z  << "]\n";

cout << "[" << rm_dblspaces(z)  << "]\n";
<code>
<pre>trim:	[(y)] 

pad:	[                (y)            XXXXXXXXXXXXXXXXXXXX]<br>

[                (y)            ]

rm_dblspaces:	[ (y) ]

[ [ q w  t e  e  4 5 66 7 77     7 888 ]]

[ [ q w t e e 4 5 66 7 77 7 888 ]]
</pre></code>
</pre>

<pre class="prettyprint">
z = "1234567890aBcDeFgHiKlMnOpQrStUvWxYz";
cout <<"truncate:\t " << "[" << truncate(z, 10)  << "]\n";

cout << "all_caps:\t" << "[" << all_caps(z)  << "]\n";

cout << "uncapitalize:\t" << "[" << uncapitalize(z)  << "]\n";


s = "This Dog has no REASON to love men.";
cout << "[" << s  << "]\n";

cout << "sentence_case:\t" << "[" << sentence_case(s)  << "]\n";

cout << "title_case:\t" << "[" << title_case(s)  << "]\n";
cout << "[" << title_case(uncapitalize(s))  << "]\n";
<code><pre>
truncate:	 [1234567890]
all_caps:	[1234567890ABCDEFGHIKLMNOPQRSTUVWXYZ]
uncapitalize:	[1234567890abcdefghiklmnopqrstuvwxyz]
[This Dog has no REASON to love men.]
sentence_case:	[This dog has no reason to love men.]
title_case:	[This Dog Has No REASON to Love Men.]
[This Dog Has No Reason to Love Men.]
</pre></code>
</pre>

<pre class="prettyprint">
s = insert(s , "good " , 16);
cout << "insert 16:\t" << "[" << s  << "]\n";

s = insert_word(s , "bad" , 4);
cout << "insert 4:\t" << "[" << s  << "]\n";

s = remove_word (s, "bad");
cout << "remove \"bad\":\t" << "[" << s  << "]\n";

s = replace_word (s, "REASON", "reason");
cout << "replace REASON reason:\t" << "[" << s  << "]\n";

s = capitalize(s);
cout << "capitalize:\t" << "[" << s  << "]\n";

s = title_case(s);
cout << "title_case" << "[" << s  << "]\n";

cout << "prepend:\t" << prepend( s, "Some " ) << endl;

cout << "append:\t"  << append( s, " So some say." ) << endl;

cout << "quote:\t" << quote(s) << endl;
<code><pre>
insert 16:	[This Dog has no good REASON to love men.]

insert 4:	[This bad Dog has no good REASON to love men.]

remove "bad":	[This Dog has no good REASON to love men.]

replace REASON reason:	[This Dog has no good reason to love men.]

capitalize:	[This Dog Has No Good Reason To Love Men.]

title_case[This Dog Has No Good Reason to Love Men.]

prepend:	Some This Dog Has No Good Reason to Love Men.

append:	This Dog Has No Good Reason to Love Men. So some say.

quote:	"This Dog Has No Good Reason to Love Men."
</pre></code>
</pre>

<pre class="prettyprint">
string t1 = after(s, "man's");
cout << "after man's :\t" << t1 << endl;

auto r = reverse(s);
cout << "reverse:\t" << "[" << r  << "]\n";
<code><pre>
after man's :	

reverse:	[.neM evoL ot nosaeR dooG oN saH goD sihT]
</pre></code>
</pre>
<hr>
<h1> Splitting and Joining </h1>
A few AllTheStrings functions generate and receive
string vectors, not individual strings. 
These are not complicated, they are a simple <code>std::vector&lt;std::string&gt;</code>.

<b>split</b> simply splits a string into a vector by spaces. 

<pre class="prettyprint">
auto v = split(s);
cout << "|\t"
for(auto s : v) cout << s << "|\t";
cout << endl;
<code><pre>
|    This|	Dog|	Has|	No|	Good|	Reason|   to|	Love|	Men.|
</pre></code>
</pre>

<b>join</b> takes a string vector and makes a single string out of it.
You can specify the conjoiner character bewteen strings.
<pre class="prettyprint">
t1 = join(v, ":");
cout << t1 << endl;
<code><pre>
This:Dog:Has:No:Good:Reason:to:Love:Men.
</pre></code>
</pre>

<b>tokenize</b> splits strings on a set of delimiters
similar to the C function, but is not destructive
of the original string, and returns a whole string vector.

<pre class="prettyprint">
cout << "tokenize:\t";
auto u = tokenize(t1, ":; ");
for(auto s : u) cout << s << endl;
<code><pre>
tokenize:	This
Dog
Has
No
Good
Reason
to
Love
Men.
</pre></code>
</pre>

<pre class="prettyprint">
auto w = tokenize(r, ":; ");
for(auto s : w)  cout << s << endl;
</pre>
<code><pre>
.neM
evoL
ot
nosaeR
dooG
oN
saH
goD
sihT
</pre></code>
</pre>
<p>
<hr>
<b>apply</b> takes a string function and performs it on a list
of arguments, then returns a single string of concatenated results.
<pre class="prettyprint">
string t = apply( reverse , "dog" , "cat", "bird", "fish", "banana");
cout << t << "\n";
<code><pre>
ananab hsif drib tac god
</pre></code>
</pre>

<p>
<b>applytoall</b> takes a string function and performs it on a list
of arguments, then returns a string vector containing each of the results.
<pre class="prettyprint">
 svector v = applytoall( all_caps ,"dog" , "cat", "bird", "fish", "banana");

 for (string s : v) cout << s << "\n";
<code><pre>
DOG
CAT
BIRD
FISH
BANANA
</pre></code>
</pre>

<hr>

<h1> random </h1>
<h2> random can generate random strings of characters <br>and mix up the letters in a string.</h2>

<pre class="prettyprint">
cout << "random:\n";
for( size_t i = 0; i < 40 ; i++)
  cout << random(t,5) << "\t";
cout << "\n";

cout << "count o:\t";
cout << count(t, "o")  << endl;

cout << "count :\t";
cout << word_count(t, ":")  << endl;

auto aa = repeat("X X" , 10);
cout << aa << "\n";

int xi=5, yi=100;

float af = 10.103, bf=-9.99e16;

string dd{"some enchanted evening"};

auto rv =  applytoall( reverse , xi ,yi, af, bf , dd);

for (auto s : rv) cout << s << "\n";

auto jj = join(rv, "/");
cout << jj << endl;

auto rjj = reverse(jj);

auto jjv = tokenize( rjj, "/");

for (auto s: jjv)  cout << s << "\t";
<code><pre>
random:
onnsr	trrr 	 n gr	a'roa	fsn'a	eebmd	 sa  	erdef	snass	rfbfb	Ds'da	aom '
b D  	s iD 	' rr'	s nsn	e'tsf	non s	osgba	i sds	  nmd	 b'er	gbotn	 ssbo fre
D d 	eram 	 e  '	ftef 	   Do	omb e	nmDr'	Demeb	nf . 	'rn a	e  as	 egse	d abt
m'.rD	r  ri

count o:	1
count:  9

X XX XX XX XX XX XX XX XX XX X


5
001
301.01
61+e3000099.9-
emos
detnahcne
gnineve

5/001/301.01/61+e3000099.9-/emos/detnahcne/gnineve

evening enchanted       some    -9.9900003e+16  10.103  100

</pre></code>
</pre>
<hr>
<h1>repaginate </h1>
<h2>repaginate reformats a paragraph string to fit a page.</h2>
You set the page width, indent, indentall (bool), 
and if indentall any additional indentation of the first line beyond that.

<pre class="prettyprint">

string P = R"WHAT(
      This is a long paragraph that may or may not have
      a bunch of words that don't make a lot of sense, but that is just because
      you don't have a clue as  to what is going on here. This is what we call a
      RAW string. It has an R\"<TOKEN>( text )<TOKEN>\" enclosing it. Weird, but effective.
      I set the pagination to a small screen 40 chars.)WHAT";

cout << P << "\n" << endl;

// <i>page width: 40, indent:6, intdent_all:true , additional first indent:5</i> 

auto Q = repaginate(P, 40, 6 , true, 5);
cout << Q << endl;
<code><pre>


      This is a long paragraph that may or may not have
      a bunch of words that don't make a lot of sense, but that is just because 
      you don't have a clue as  to what is going on here. This is what we call a 
      RAW string. It has an R\"<TOKEN>( text )<TOKEN>\" enclosing it. Weird, but effective.
      I set the pagination to a small screen 40 chars.


 
         This is a long paragraph that may or may
      not have a bunch of words that don't make a lot of sense,
      but that is just because you don't have a clue as to
      what is going on here. This is what we call a RAW string.
      It has an R\"<TOKEN>( text )<TOKEN>\" enclosing
      it. Weird, but effective. I set the pagination to
      a small screen 40 chars.


</pre></code>
</pre>
<hr>
<h1>rep and frep</h1>
<h2>rep and frep create a <i>numerical</i> string</h2>
with a set precision and formatting. rep does integer types
and frep does floating point types. rep will call frep instead
if the argument is a floating point number.

<pre class="prettyprint">

cout << " double:\t" << std::setprecision(20) 
     << fprep( 11.000002 * 35.5387, 20, std::scientific) 
     << endl;

const double PI = 3.141592653589793;
cout << "fixed:\t" << rep( PI, std::fixed) << "\n";
<code><pre>
double:   3.90925771077399986098e+02

fixed:    3.14159265358979311600
</pre></code>
</pre>

<h1>format</h1>
<h2>format is the equivalent of <i>std::sprintf</i>.</h2>
In that it formats a string with printf format codes.
(It is not completely safe, in that incorrect formatting codes
can lead to seg faults, just like in C. Be careful.)
<pre class="prettyprint">
string formatstr("this is a %s string:\t%zu\t%f and all that %s \n");

string bb;
bb = format( formatstr.c_str() , "format" , 567 , 3.14159 , "stuff", 13  );
cout << bb ;

<code><pre>
this is a format string:	567	3.141590 and all that stuff 
</pre></code>

bb = format( "%f\n", -10.2 );
cout << bb  << endl;

bb = format( "%d\n", -10.2 );
cout << bb  << endl;
<code><pre>
-10.200000
-10
</pre></code>
</pre>


<pre class="prettyprint">
ats_banner(); // ASCII ART
</pre>
<code><pre>
<font color="blue">

 _____ _ _    _____ _          _____ _       _             
|  _  | | |  |_   _| |_ ___   |   __| |_ ___|_|___ ___ ___ 
|     | | |    | | |   | -_|  |__   |  _|  _| |   | . |_ -|
|__|__|_|_|    |_| |_|_|___|  |_____|_| |_| |_|_|_|_  |___|
                                                  |___|    

</font>
</pre></code>
</pre
<p><p>
<hr>
<h1><b>ADVANCED USAGE</b></h1>

<h1>Value</h1>
<pre class="prettyprint" >
  template&lt;typename T&gt;
  T value( const std::string& s);
</pre>

The <b>value</b> template function returns the string as a numerical value
if it can and a string if it cannot.

Strings such as "3.14159"  can become values with a type given as 
a template  like:
<p>
 <pre class="prettyprint" >
   string s{ "3.14159"};
   double pi = value<double>(s);
   cout << pi << endl;

   int i = value<int>(s);
   cout << i << endl;
<code> <pre>
3.141590	 
3
</pre>
</code>
</pre>

<h1>interpolate</h1>

<b>interpolate</b> substitutes the positional arguments given into a string.
 <pre class="prettyprint" >

template&lt;typename S, typename... Args&gt;
string interpolate( const S& orig , const Args&... args);
</pre>

The numbered arguments in braces are replaced by the positional
arguments given to the function. You don't have to use them all,
but you must have at least as many as the larges positional number
in the string. The braced tokens don't need to be in order.

<pre class="prettyprint" >
  int main()
   {
     string s{"This is {4} and {2} and {3} and {1}."};

     string a{"one"}, b{"two"} , c{"three"}, d{"four"};

     string t = interpolate( s , a , b, c , d);

     std::cout << t << std::endl;
   }
<code> <pre>
This is four and two and three and one.
</pre></code>
</pre>


<h1>COLOR</h1>
<img src="256colorcodes.png"> </img>
<p>
ANSI 16 and 256 color is supported for text output.
<p>
If you enable USE_COLOR in your compiler defines
You will be able to print to the screen in 16 or 256
color text.
<p>
Invoking the function <b>ats_color_init()</b> initializes and returns
an <i>associative map<i> containing strings that colorize text.
You can call them by name in array-style.
<p>
Or you can call the functions 
<b>color16()</b> or <b>color256()</b> 
with a number in the range 0-15, and 0-255, respectively.
<p>
The <b>colorstring</b> function allows a string to be
colored with an integer [0-255].
<font size="3" color="blue">
<code>
<pre>
     Makefile<br>

     DEFINES += -DUSE_SMALL_WORDS -DUSE_COLOR
     
</pre>
</code>
<pre class="prettyprint" > 
     auto color = ats_color_init();

     string s("Dogs are man's best friend.");
     cout << color["bold"] << s << color["normal"] << "\n";						   
     string t(s);

     string tmp{"best"};
  
     cout << "all_caps:\t" << color["green"]  << all_caps(t)       << color["normal"] <<"\n"
          << "quote:\t"    << color["red"]    << quote(t)          << color["normal"] << "\n"
          << "unquote:\t"  << color["purple"] << unquote(quote(t)) << color["normal"] 
          << endl;

    for ( int i = 0; i < 255; i++)
      { 
        if( i>0 && !(i%16)) cout << endl; 
        cout << color256(i) << "[" << i << "]" << "\t";
      }

    cout << color["normal"] << endl;

    cout << colorstring( "This is a colored string." , 162 ) << "\n";
    cout << colorstring( "This is a colored string." , 62 )  << "\n";
    cout << colorstring( "This is a colored string." , 148 ) << "\n";
    cout << color16(red) << "This should be red.";
    cout << color16(normal) << endl;
							
</pre>
</code>
</font>
<img src="color_example.png"></img>  
<p> 
<hr>
<h1>IMPROVEMENTS</h1>
<h2>
   There is always room for improvement in code. <br>
   Experiment; stumble; break; repair; leap forward. <br>
   Get better by doing, by impact.<br>
   I appreciate suggestions and/or criticisms from users and<br>
   experts and welcome submissions. Flames go to <i>/dev/null</i>.<br>
   happy coding!      <br>
  
 Enjoy!    <br>
</h2>
</div>


</body>
</html>
